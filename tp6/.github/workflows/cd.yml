name: CD Pipeline

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
    - uses: actions/checkout@v3

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure Kubernetes
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.12.0'

    - name: Deploy with Helm
      run: |
        helm upgrade --install my-app ./01-helm/my-app \
          --namespace production \
          --create-namespace \
          --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ github.sha }} \
          --wait \
          --timeout 5m

    - name: Verify deployment
      run: |
        # Le nom du deployment dépend du release name Helm et du chart
        # Format: <release-name>-<chart-name>
        DEPLOYMENT_NAME=$(kubectl get deployments -n production -l app.kubernetes.io/instance=my-app -o jsonpath='{.items[0].metadata.name}')
        kubectl rollout status deployment/$DEPLOYMENT_NAME -n production
        kubectl get pods -n production

    - name: Run smoke tests
      run: |
        kubectl run smoke-test --image=curlimages/curl:latest --rm -i --restart=Never \
          -- curl -f http://my-app-service.production.svc.cluster.local/health

  notify:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Send notification
      run: |
        echo "Deployment completed with status: ${{ needs.deploy.result }}"
        # Ajouter ici l'intégration avec Slack, Discord, etc.
